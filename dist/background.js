(()=>{"use strict";console.log("Background service worker started.");const e=["audio/mpeg","audio/mp4","audio/ogg","audio/wav","audio/webm","audio/flac"],o=[".flac",".mp3",".mp4",".mpeg",".mpga",".m4a",".ogg",".wav",".webm"],r=41943040,t={".mp3":"audio/mpeg",".mp4":"audio/mp4",".m4a":"audio/mp4",".ogg":"audio/ogg",".wav":"audio/wav",".webm":"audio/webm",".flac":"audio/flac",".mpeg":"audio/mpeg",".mpga":"audio/mpeg"},n="offscreen.html";let a=null;async function s(e){const o=await async function(e){if(!chrome.runtime.getContexts)return console.warn("chrome.runtime.getContexts is not available."),!1;try{const o=chrome.runtime.getURL(e);return(await chrome.runtime.getContexts({contextTypes:[chrome.runtime.ContextType.OFFSCREEN_DOCUMENT],documentUrls:[o]})).length>0}catch(e){return console.error("Error checking for offscreen document:",e),!1}}(e);if(o)console.log("Offscreen document already exists.");else if(a)await a;else{const o=chrome.runtime.getURL(e);a=chrome.offscreen.createDocument({url:o,reasons:[chrome.offscreen.Reason.DOM_PARSER],justification:"Fetching downloaded audio file content"});try{await a,console.log("Offscreen document created successfully.")}catch(e){if(console.error("Failed to create offscreen document:",e),!e.message.includes("Only a single offscreen document may be created"))throw e;console.warn("Attempted to create offscreen document when one already existed.")}finally{a=null}}}async function i(){console.warn("DEBUG: closeOffscreenDocument called but is disabled.")}chrome.downloads.onChanged.addListener((async r=>{if("complete"===r.state?.current&&"complete"!==r.state.previous)try{const t=await chrome.downloads.search({id:r.id});if(t.length>0){const r=t[0];console.log("Download complete:",r);const n=e.includes(r.mime.toLowerCase()),a=o.some((e=>r.filename.toLowerCase().endsWith(e)));(n||a)&&r.filename&&r.id?(console.log(`Supported audio file downloaded: ${r.filename}`),await chrome.storage.local.set({pendingDownload:{downloadId:r.id,filename:r.filename,url:r.url,fileSize:r.fileSize,mime:r.mime},transcriptionState:"pending_user_action",transcriptionResult:null,transcriptionError:null}),console.log("Stored pending download:",r.id),chrome.runtime.sendMessage({action:"updatePopupState"}).catch((e=>console.log("Popup not open or listening?")))):console.log(`Ignoring unsupported file: ${r.filename} (MIME: ${r.mime})`)}}catch(e){console.error("Error processing download change:",e)}})),chrome.runtime.onMessage.addListener(((o,a,c)=>{console.log("Message received in background:",o,"from:",a.id);let l=!1;if("startTranscription"===o.action){const e=o.downloadId;e&&chrome.storage.local.set({transcriptionState:"loading"}).then((()=>{chrome.runtime.sendMessage({action:"updatePopupState"}).catch((e=>console.log("Popup not open?"))),async function(e){console.log(`Handling transcription request for download ID: ${e}`);try{const{groqApiKey:o}=await chrome.storage.local.get("groqApiKey");if(!o)throw new Error("Groq API key not set. Please set it in the extension options.");const{pendingDownload:r}=await chrome.storage.local.get("pendingDownload");if(!r||r.downloadId!==e)throw console.warn(`Transcription requested for ${e}, but pending download is different or missing.`),new Error("Relevant download details not found. Please try downloading the file again.");console.log("Found pending download details:",r),await s(n),await chrome.storage.local.set({transcriptionState:"fetching"}),chrome.runtime.sendMessage({action:"updatePopupState"}).catch((e=>console.log("Popup not open?"))),console.log(`Sending fetch request to offscreen for ORIGINAL URL: ${r.url}`),await chrome.runtime.sendMessage({target:"offscreen",type:"fetch-audio-data",data:{url:r.url,downloadId:e}}),console.log("Fetch request sent to offscreen document.")}catch(o){console.error(`Transcription failed during setup/fetch dispatch [DownloadID: ${e}]:`,o);const r=o instanceof Error?o.message:"Unknown transcription error during setup";await chrome.storage.local.set({transcriptionState:"error",transcriptionError:r,pendingDownload:null}),chrome.runtime.sendMessage({action:"updatePopupState"}).catch((e=>console.log("Popup not open?")))}}(e)}))}else if("cancelTranscription"===o.action){const e=o.downloadId;chrome.storage.local.remove(["pendingDownload","transcriptionState","transcriptionResult","transcriptionError"]),i(),console.log(`Transcription cancelled by user for download ${e}`)}else if("requestOffscreenClose"===o.action)console.log("Received request from popup to close offscreen document."),i();else{if("sendChatMessage"===o.action){l=!0;const{model:e,messages:r}=o.payload;return async function(){try{return(await chrome.storage.local.get("groqApiKey")).groqApiKey||null}catch(e){return console.error("Error retrieving Groq API key:",e),null}}().then((o=>{if(!o)return console.error("API Key not found for chat request."),chrome.runtime.sendMessage({action:"chatError",payload:{error:"API key not set."}}).catch((e=>console.log("Popup not open or listening for chatError?"))),void c({success:!1,error:"API key not set."});const t=[{role:"system",content:"You are a helpful assistant called Mark, you are an expert in the field of the swedish rental market and law"},...r];(async function(e,o,r){console.log(`Starting streaming Groq Chat API call with model: ${o}`);const t={Authorization:`Bearer ${e}`,"Content-Type":"application/json"},n=JSON.stringify({model:o,messages:r,stream:!0});let a="";try{console.log("[Background] Streaming Groq Chat API Call - Messages Payload:",JSON.stringify(r.map((e=>({role:e.role,content:"string"==typeof e.content?`${e.content.substring(0,100)}...`:"[Object/Array]"})))));const e=await fetch("https://api.groq.com/openai/v1/chat/completions",{method:"POST",headers:t,body:n});if(!e.ok){const o=await e.text();throw console.error("Groq API Streaming Error Response:",e.status,o),new Error(`API stream request failed with status ${e.status}: ${o}`)}if(!e.body)throw new Error("Response body is null");const o=e.body.pipeThrough(new TextDecoderStream).getReader();let s="";for(;;){const{done:e,value:r}=await o.read();if(e){console.log("Stream finished.");break}s+=r;let t=s.split("\n\n");s=t.pop()||"";for(const e of t)if(e.startsWith("data: ")){const o=e.substring(6).trim();if("[DONE]"===o){console.log("Received [DONE] marker.");continue}try{const e=JSON.parse(o),r=e.choices?.[0]?.delta?.content;r&&(a+=r,chrome.runtime.sendMessage({action:"addAiChatChunk",payload:{chunk:r}}).catch((e=>console.log("Popup not open or listening for chat chunk?")))),e.choices?.[0]?.finish_reason&&console.log("Stream finished with reason:",e.choices[0].finish_reason)}catch(e){console.error("Error parsing stream data JSON:",e,"Data:",o)}}}chrome.runtime.sendMessage({action:"endAiChatStream",payload:{fullResponse:a}}).catch((e=>console.log("Popup not open or listening for stream end?")))}catch(e){console.error("Error during Groq Chat API stream processing:",e),chrome.runtime.sendMessage({action:"chatError",payload:{error:(e instanceof Error?e.message:String(e))||"Failed to process AI stream."}}).catch((e=>console.log("Popup not open or listening for stream error?")))}})(o,e,t).catch((e=>{console.error("Error initiating Groq Chat API stream:",e),chrome.runtime.sendMessage({action:"chatError",payload:{error:(e instanceof Error?e.message:String(e))||"Failed to start AI stream."}}).catch((e=>console.log("Popup not open or listening for initial stream error?"))),c({success:!1,error:"Failed to start AI stream"})})),c({success:!0,message:"Stream initiated"})})).catch((e=>{console.error("Error retrieving API key before streaming:",e),chrome.runtime.sendMessage({action:"chatError",payload:{error:"Failed to retrieve API key."}}).catch((e=>console.log("Popup not open or listening for API key error?"))),c({success:!1,error:"Failed to retrieve API key."})})),!0}if("setSelectedText"===o.action){const e=o.payload?.text;"string"==typeof e?(console.log("[Background] Received selected text:",e.substring(0,100)+"..."),chrome.storage.local.set({lastSelectedText:e}).then((()=>{console.log("[Background] Stored selected text."),chrome.action.openPopup({},(()=>{chrome.runtime.lastError?console.warn(`[Background] Could not open popup programmatically: ${chrome.runtime.lastError.message}. User might need to click the icon.`):console.log("[Background] Popup opened programmatically.")})),c({success:!0})})).catch((e=>{console.error("[Background] Error storing selected text:",e),c({success:!1,error:e.message})})),l=!0):(console.warn("[Background] Received invalid payload for setSelectedText:",o.payload),c({success:!1,error:"Invalid payload"}))}else if("background"===o.target)switch(o.action){case"offscreenLogData":console.warn("--- Received Offscreen Logs ---"),console.log(o.data),console.warn("-------------------------------");break;case"audioDataFetched":console.log(`[Background] Received audioDataFetched for downloadId: ${o.downloadId}`);let n=null;if(o.isBase64&&"string"==typeof o.data){console.log("[Background] Received data is Base64 encoded. Decoding...");try{n=function(e){const o=atob(e),r=o.length,t=new Uint8Array(r);for(let e=0;e<r;e++)t[e]=o.charCodeAt(e);return t.buffer}(o.data),console.log(`[Background] Decoded Base64 to ArrayBuffer (byteLength: ${n.byteLength})`)}catch(e){console.error("[Background] Error decoding Base64 string:",e),n=null}}else if(console.warn("[Background] Received audio data was NOT Base64 encoded string as expected."),console.log("[Background] Type of received message.data: "+typeof o.data),console.log(`[Background] Is message.data an ArrayBuffer? ${o.data instanceof ArrayBuffer}`),o.data instanceof ArrayBuffer)try{console.log(`[Background] Received data byteLength: ${o.data.byteLength}`)}catch(e){console.error("[Background] Error accessing byteLength:",e)}else console.warn("[Background] Received message.data is NOT an ArrayBuffer. Data:",o.data);i(),n?async function(o,n){console.log(`Processing fetched audio data for downloadId ${o} (${n.byteLength} bytes).`);let a,s="",i="audio_file";try{const{groqApiKey:c,pendingDownload:l}=await chrome.storage.local.get(["groqApiKey","pendingDownload"]);if(!c)throw new Error("Groq API key not found in storage.");if(s=c,l&&l.downloadId===o)i=l.filename||i,a=l.mime,console.log(`Retrieved filename: ${i}, MIME type: ${a}`);else{console.warn(`Could not retrieve original details for downloadId ${o}. Using defaults.`);const e=await chrome.downloads.search({id:o});e.length>0&&(i=e[0].filename||i,a=e[0].mime,console.log(`Fallback retrieved filename: ${i}, MIME type: ${a}`))}if(n.byteLength>r)throw console.error(`File size (${n.byteLength} bytes) exceeds maximum limit (41943040 bytes).`),new Error(`Audio file is too large (${(n.byteLength/1048576).toFixed(2)} MB). Maximum size is 40 MB. File splitting is not yet implemented.`);if(await chrome.storage.local.set({transcriptionState:"transcribing"}),chrome.runtime.sendMessage({action:"updatePopupState"}).catch((e=>console.log("Popup not open?"))),!a&&i){console.warn(`MIME type for downloadId ${o} is missing. Attempting inference from filename: ${i}`);const e=i.substring(i.lastIndexOf(".")).toLowerCase(),r=t[e];r?(console.log(`Inferred MIME type: ${r}`),a=r):console.warn(`Could not infer MIME type from extension: ${e}`)}if(!a||!e.includes(a)){const e=`Could not determine a supported audio MIME type for the file. Detected/inferred type: ${a||"none"}. Filename: ${i||"unknown"}`;throw console.error(e),new Error(e)}console.log(`Creating Blob with explicitly set MIME type: ${a}`);const d=new Blob([n],{type:a}),g=new FormData;let u="audio_file";i?(u=i.substring(i.lastIndexOf("/")+1),u=u.substring(u.lastIndexOf("\\")+1),console.log(`Using base filename: ${u}`)):console.log("Using default filename: audio_file"),g.append("file",d,u),g.append("model","whisper-large-v3-turbo"),g.append("response_format","verbose_json"),console.log("Calling Groq API with model whisper-large-v3-turbo and verbose_json...");const p=Date.now(),m=await fetch("https://api.groq.com/openai/v1/audio/transcriptions",{method:"POST",headers:{Authorization:`Bearer ${s}`},body:g}),f=Date.now();if(console.log(`Groq API call finished in ${f-p}ms. Status: ${m.status}`),!m.ok){let e="Unknown API error";try{const o=await m.json();e=o?.error?.message||JSON.stringify(o)}catch(o){e=await m.text()}throw new Error(`Groq API error: ${m.status} ${m.statusText}. Details: ${e}`)}const h=await m.json(),w=h?.text;if("string"!=typeof w)throw console.error("Groq API verbose_json response missing text field:",h),new Error("Groq API response did not contain valid transcription text.");console.log("Transcription successful."),await chrome.storage.local.set({transcriptionState:"complete",transcriptionResult:w,transcriptionError:null,pendingDownload:null}),chrome.runtime.sendMessage({action:"transcriptionComplete",transcription:w}).catch((e=>console.log("Popup not open?")))}catch(e){console.error("Error during audio processing or API call:",e);const o=e instanceof Error?e.message:"Unknown error during transcription processing";await chrome.storage.local.set({transcriptionState:"error",transcriptionError:o,transcriptionResult:null,pendingDownload:null}),chrome.runtime.sendMessage({action:"updatePopupState"}).catch((e=>console.log("Popup not open?")))}}(o.downloadId,n):(console.error("[Background] Cannot process audio data due to decoding failure or invalid data format."),chrome.storage.local.set({transcriptionState:"error",transcriptionError:"Internal error: Failed to decode/receive audio data correctly from fetch process.",pendingDownload:null}).then((()=>{chrome.runtime.sendMessage({action:"updatePopupState"}).catch((e=>console.log("Popup not open?")))})));break;case"audioFetchError":console.error(`Error fetching audio from offscreen document for downloadId ${o.downloadId}:`,o.error);const a=o.error||"Failed to fetch audio via offscreen document";chrome.storage.local.set({transcriptionState:"error",transcriptionError:a,pendingDownload:null}).then((()=>{chrome.runtime.sendMessage({action:"updatePopupState"}).catch((e=>console.log("Popup not open?")))}));break;case"clipboardDataResponse":console.log("Received clipboardDataResponse from offscreen"),async function(o){if(!o)return void console.log("Clipboard is empty or could not be read.");let t;console.log("Received clipboard content from offscreen:",o);try{if(t=new URL(o.trim()),!["http:","https:"].includes(t.protocol))throw new Error("Invalid protocol")}catch(e){return void console.log("Clipboard text is not a valid HTTP/HTTPS URL:",o)}console.log("Valid URL found in clipboard:",t.href);try{console.log(`Fetching HEAD for ${t.href}`);const o=await fetch(t.href,{method:"HEAD"});if(!o.ok)throw new Error(`HEAD request failed: ${o.status} ${o.statusText}`);const n=o.headers.get("content-type")?.split(";")[0].trim(),a=o.headers.get("content-length"),s=a?parseInt(a,10):0;console.log(`HEAD response - Content-Type: ${n}, Size: ${s} bytes`);const c=n&&e.includes(n),l=s>0&&s<=r;if(!c)throw new Error(`Unsupported audio format (MIME: ${n||"unknown"}). Supported types: ${e.join(", ")}`);if(!l)throw new Error(`Audio file size (${s} bytes) is too large or unknown. Max: 41943040 bytes.`);let d=t.pathname.substring(t.pathname.lastIndexOf("/")+1)||"audio_from_url";d=decodeURIComponent(d),console.log("Storing pending URL information..."),await chrome.storage.local.set({pendingDownload:{downloadId:Date.now(),filename:d,url:t.href,fileSize:s,mime:n,isUrlSource:!0},transcriptionState:"pending_user_action",transcriptionResult:null,transcriptionError:null}),chrome.runtime.sendMessage({action:"updatePopupState"}).catch((e=>console.log("Popup not open or listening?"))),console.log("URL processing successful, closing offscreen document."),i()}catch(e){console.error("Error during HEAD request or processing URL info:",e);const o=e instanceof Error?e.message:"Error validating audio URL.";await chrome.storage.local.set({transcriptionState:"error",transcriptionError:o}),chrome.runtime.sendMessage({action:"updatePopupState"}).catch((e=>console.log("Popup not open?")))}}(o.data);break;case"clipboardReadError":console.error("Error reading clipboard from offscreen:",o.error),chrome.storage.local.set({transcriptionState:"error",transcriptionError:o.error||"Failed to read clipboard."}).then((()=>{chrome.runtime.sendMessage({action:"updatePopupState"}).catch((e=>console.log("Popup not open?")))}));break;default:console.warn("Received unknown action from offscreen:",o.action)}}return l})),console.log("Background script listeners attached.");const c="transcribeAudioLink";chrome.runtime.onInstalled.addListener((()=>{chrome.contextMenus.create({id:c,title:"Transcribe Audio Link from Clipboard",contexts:["page","selection","link","audio","video"]}),console.log("Context menu created.")})),chrome.contextMenus.onClicked.addListener(((e,o)=>{e.menuItemId===c&&(console.log("'Transcribe Audio Link from Clipboard' context menu clicked."),async function(){console.log("Handling transcribe from clipboard request...");try{await s(n),console.log("Sending read-clipboard request to offscreen document."),await chrome.runtime.sendMessage({target:"offscreen",type:"read-clipboard"})}catch(e){console.error("Error initiating clipboard read via offscreen:",e);const o=e instanceof Error?e.message:"Failed to initiate clipboard reading.";await chrome.storage.local.set({transcriptionState:"error",transcriptionError:o}),chrome.runtime.sendMessage({action:"updatePopupState"}).catch((e=>console.log("Popup not open?")))}}())}))})();