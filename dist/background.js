(()=>{"use strict";console.log("Background service worker started.");const e=["audio/mpeg","audio/mp3","audio/mp4","audio/ogg","audio/wav","audio/webm","audio/flac"],o=[".flac",".mp3",".mp4",".mpeg",".mpga",".m4a",".ogg",".wav",".webm"],r={".mp3":"audio/mpeg",".mp4":"audio/mp4",".m4a":"audio/mp4",".ogg":"audio/ogg",".wav":"audio/wav",".webm":"audio/webm",".flac":"audio/flac",".mpeg":"audio/mpeg",".mpga":"audio/mpeg"},t=Object.entries(r).reduce(((e,[o,r])=>("audio/mpeg"!==r||e[r]?"audio/mp4"!==r||e[r]?e[r]||(e[r]=o):e[r]=".m4a":e[r]=".mp3",e)),{});t["audio/mp3"]=".mp3",console.log("MIME to Extension Map:",t);const n="offscreen.html";let a=null;async function s(e){const o=await async function(e){if(!chrome.runtime.getContexts)return console.warn("chrome.runtime.getContexts is not available."),!1;try{const o=chrome.runtime.getURL(e);return(await chrome.runtime.getContexts({contextTypes:[chrome.runtime.ContextType.OFFSCREEN_DOCUMENT],documentUrls:[o]})).length>0}catch(e){return console.error("Error checking for offscreen document:",e),!1}}(e);if(o)console.log("Offscreen document already exists.");else if(a)await a;else{const o=chrome.runtime.getURL(e);a=chrome.offscreen.createDocument({url:o,reasons:[chrome.offscreen.Reason.DOM_PARSER],justification:"Fetching downloaded audio file content"});try{await a,console.log("Offscreen document created successfully.")}catch(e){if(console.error("Failed to create offscreen document:",e),!e.message.includes("Only a single offscreen document may be created"))throw e;console.warn("Attempted to create offscreen document when one already existed.")}finally{a=null}}}async function c(){console.warn("DEBUG: closeOffscreenDocument called but is disabled.")}async function i(e){console.log(`Handling transcription request for download ID: ${e}`),chrome.action.openPopup({},(()=>{chrome.runtime.lastError?console.warn(`[Background] Could not open popup programmatically: ${chrome.runtime.lastError.message}. User might need to click the icon.`):console.log("[Background] Popup opened programmatically for transcription request.")}));try{const{groqApiKey:o}=await chrome.storage.local.get("groqApiKey");if(!o)throw new Error("Groq API key not set. Please set it in the extension options.");const{pendingDownload:r}=await chrome.storage.local.get("pendingDownload");if(!r||r.downloadId!==e)throw console.warn(`Transcription requested for ${e}, but pending download is different or missing.`),new Error("Relevant download details not found. Please try downloading the file again.");console.log("Found pending download details:",r),await s(n),await chrome.storage.local.set({transcriptionState:"fetching"}),chrome.runtime.sendMessage({action:"updatePopupState"}).catch((e=>console.log("Popup not open?"))),console.log(`Sending fetch request to offscreen for ORIGINAL URL: ${r.url}`),await chrome.runtime.sendMessage({target:"offscreen",type:"fetch-audio-data",data:{url:r.url,downloadId:e}}),console.log("Fetch request sent to offscreen document.")}catch(o){console.error(`Transcription failed during setup/fetch dispatch [DownloadID: ${e}]:`,o);const r=o instanceof Error?o.message:"Unknown transcription error during setup";await chrome.storage.local.set({transcriptionState:"error",transcriptionError:r,pendingDownload:null}),chrome.runtime.sendMessage({action:"updatePopupState"}).catch((e=>console.log("Popup not open?")))}}chrome.downloads.onChanged.addListener((async r=>{if("complete"===r.state?.current&&"complete"!==r.state.previous)try{const t=await chrome.downloads.search({id:r.id});if(t.length>0){const r=t[0];console.log("Download complete:",r);const n=e.includes(r.mime.toLowerCase()),a=o.some((e=>r.filename.toLowerCase().endsWith(e)));(n||a)&&r.filename&&r.id?(console.log(`Supported audio file downloaded: ${r.filename}`),await chrome.storage.local.set({pendingDownload:{downloadId:r.id,filename:r.filename,url:r.url,fileSize:r.fileSize,mime:r.mime},transcriptionState:"pending_user_action",transcriptionResult:null,transcriptionError:null}),console.log("Stored pending download:",r.id),chrome.runtime.sendMessage({action:"updatePopupState"}).catch((e=>console.log("Popup not open or listening?")))):console.log(`Ignoring unsupported file: ${r.filename} (MIME: ${r.mime})`)}}catch(e){console.error("Error processing download change:",e)}})),chrome.runtime.onMessage.addListener(((o,n,a)=>{console.log("Message received in background:",o,"from:",n.id);let s=!1;if("startTranscription"===o.action){const e=o.downloadId;e&&chrome.storage.local.set({transcriptionState:"loading"}).then((()=>{chrome.runtime.sendMessage({action:"updatePopupState"}).catch((e=>console.log("Popup not open?"))),i(e)}))}else if("cancelTranscription"===o.action){const e=o.downloadId;chrome.storage.local.remove(["pendingDownload","transcriptionState","transcriptionResult","transcriptionError"]),c(),console.log(`Transcription cancelled by user for download ${e}`)}else if("requestOffscreenClose"===o.action)console.log("Received request from popup to close offscreen document."),c();else{if("sendChatMessage"===o.action){s=!0;const{model:e,messages:r}=o.payload;return async function(){try{return(await chrome.storage.local.get("groqApiKey")).groqApiKey||null}catch(e){return console.error("Error retrieving Groq API key:",e),null}}().then((o=>{if(!o)return console.error("API Key not found for chat request."),chrome.runtime.sendMessage({action:"chatError",payload:{error:"API key not set."}}).catch((e=>console.log("Popup not open or listening for chatError?"))),void a({success:!1,error:"API key not set."});const t=[{role:"system",content:"You are a helpful assistant called Mark, you are an expert in the field of the swedish rental market and law"},...r];(async function(e,o,r){console.log(`Starting streaming Groq Chat API call with model: ${o}`);const t={Authorization:`Bearer ${e}`,"Content-Type":"application/json"},n=JSON.stringify({model:o,messages:r,stream:!0});let a="";try{console.log("[Background] Streaming Groq Chat API Call - Messages Payload:",JSON.stringify(r.map((e=>({role:e.role,content:"string"==typeof e.content?`${e.content.substring(0,100)}...`:"[Object/Array]"})))));const e=await fetch("https://api.groq.com/openai/v1/chat/completions",{method:"POST",headers:t,body:n});if(!e.ok){const o=await e.text();throw console.error("Groq API Streaming Error Response:",e.status,o),new Error(`API stream request failed with status ${e.status}: ${o}`)}if(!e.body)throw new Error("Response body is null");const o=e.body.pipeThrough(new TextDecoderStream).getReader();let s="";for(;;){const{done:e,value:r}=await o.read();if(e){console.log("Stream finished.");break}s+=r;let t=s.split("\n\n");s=t.pop()||"";for(const e of t)if(e.startsWith("data: ")){const o=e.substring(6).trim();if("[DONE]"===o){console.log("Received [DONE] marker.");continue}try{const e=JSON.parse(o),r=e.choices?.[0]?.delta?.content;r&&(a+=r,chrome.runtime.sendMessage({action:"addAiChatChunk",payload:{chunk:r}}).catch((e=>console.log("Popup not open or listening for chat chunk?")))),e.choices?.[0]?.finish_reason&&console.log("Stream finished with reason:",e.choices[0].finish_reason)}catch(e){console.error("Error parsing stream data JSON:",e,"Data:",o)}}}chrome.runtime.sendMessage({action:"endAiChatStream",payload:{fullResponse:a}}).catch((e=>console.log("Popup not open or listening for stream end?")))}catch(e){console.error("Error during Groq Chat API stream processing:",e),chrome.runtime.sendMessage({action:"chatError",payload:{error:(e instanceof Error?e.message:String(e))||"Failed to process AI stream."}}).catch((e=>console.log("Popup not open or listening for stream error?")))}})(o,e,t).catch((e=>{console.error("Error initiating Groq Chat API stream:",e),chrome.runtime.sendMessage({action:"chatError",payload:{error:(e instanceof Error?e.message:String(e))||"Failed to start AI stream."}}).catch((e=>console.log("Popup not open or listening for initial stream error?"))),a({success:!1,error:"Failed to start AI stream"})})),a({success:!0,message:"Stream initiated"})})).catch((e=>{console.error("Error retrieving API key before streaming:",e),chrome.runtime.sendMessage({action:"chatError",payload:{error:"Failed to retrieve API key."}}).catch((e=>console.log("Popup not open or listening for API key error?"))),a({success:!1,error:"Failed to retrieve API key."})})),!0}if("setSelectedText"===o.action){const e=o.payload?.text;"string"==typeof e?(console.log("[Background] Received selected text:",e.substring(0,100)+"..."),chrome.storage.local.set({lastSelectedText:e}).then((()=>{console.log("[Background] Stored selected text."),chrome.action.openPopup({},(()=>{chrome.runtime.lastError?console.warn(`[Background] Could not open popup programmatically: ${chrome.runtime.lastError.message}. User might need to click the icon.`):console.log("[Background] Popup opened programmatically.")})),a({success:!0})})).catch((e=>{console.error("[Background] Error storing selected text:",e),a({success:!1,error:e.message})})),s=!0):(console.warn("[Background] Received invalid payload for setSelectedText:",o.payload),a({success:!1,error:"Invalid payload"}))}else if("background"===o.target)switch(o.action){case"offscreenLogData":console.warn("--- Received Offscreen Logs ---"),console.log(o.data),console.warn("-------------------------------");break;case"audioDataFetched":console.log(`[Background] Received audioDataFetched for downloadId: ${o.downloadId}`);let n=null;const a=o.contentType;if(console.log(`[Background] Content-Type from offscreen: ${a}`),o.isBase64&&"string"==typeof o.data){console.log("[Background] Received data is Base64 encoded. Decoding...");try{n=function(e){const o=atob(e),r=o.length,t=new Uint8Array(r);for(let e=0;e<r;e++)t[e]=o.charCodeAt(e);return t.buffer}(o.data),console.log(`[Background] Decoded Base64 to ArrayBuffer (byteLength: ${n.byteLength})`)}catch(e){console.error("[Background] Error decoding Base64 string:",e),n=null}}else if(console.warn("[Background] Received audio data was NOT Base64 encoded string as expected."),console.log("[Background] Type of received message.data: "+typeof o.data),console.log(`[Background] Is message.data an ArrayBuffer? ${o.data instanceof ArrayBuffer}`),o.data instanceof ArrayBuffer)try{console.log(`[Background] Received data byteLength: ${o.data.byteLength}`)}catch(e){console.error("[Background] Error accessing byteLength:",e)}else console.warn("[Background] Received message.data is NOT an ArrayBuffer. Data:",o.data);c(),n?async function(o,n,a){console.log(`Processing fetched audio data for downloadId ${o} (${n.byteLength} bytes). Content-Type from fetch: ${a}`);let s,c="",i="audio_file";try{const{groqApiKey:l,pendingDownload:d}=await chrome.storage.local.get(["groqApiKey","pendingDownload"]);if(!l)throw new Error("Groq API key not found in storage.");if(c=l,d&&d.downloadId===o)i=d.filename||i,s=d.mime,console.log(`Retrieved filename: ${i}, MIME type from storage: ${s}`);else{console.warn(`Could not retrieve original details for downloadId ${o}. Using defaults.`);const e=await chrome.downloads.search({id:o});e.length>0&&(i=e[0].filename||i,s=e[0].mime,console.log(`Fallback retrieved filename: ${i}, MIME type: ${s}`))}if(a&&"string"==typeof a&&(console.log(`Using Content-Type directly from fetch response: ${a}`),s=a),n.byteLength>41943040)throw console.error(`File size (${n.byteLength} bytes) exceeds maximum limit (41943040 bytes).`),new Error(`Audio file is too large (${(n.byteLength/1048576).toFixed(2)} MB). Maximum size is 40 MB. File splitting is not yet implemented.`);if(await chrome.storage.local.set({transcriptionState:"transcribing"}),chrome.runtime.sendMessage({action:"updatePopupState"}).catch((e=>console.log("Popup not open?"))),!s&&i){console.warn(`MIME type for downloadId ${o} is missing. Attempting inference from filename: ${i}`);const e=i.substring(i.lastIndexOf(".")).toLowerCase(),t=r[e];t?(console.log(`Inferred MIME type: ${t}`),s=t):console.warn(`Could not infer MIME type from extension: ${e}`)}if(!s||!e.includes(s)){const e=`Could not determine a supported audio MIME type for the file. Detected/inferred type: ${s||"none"}. Filename: ${i||"unknown"}`;throw console.error(e),new Error(e)}console.log(`Creating Blob with explicitly set MIME type: ${s}`);const p=new Blob([n],{type:s}),g=new FormData;let u="audio_file";const m=t[s];m?(u=`api_upload${m}`,console.log(`Using filename for API based on MIME type: ${u}`)):(u=i?i.substring(i.lastIndexOf("/")+1).substring(i.lastIndexOf("\\")+1):"audio_file.bin",console.warn(`Could not map MIME type '${s}' to extension. Using filename: ${u}`)),g.append("file",p,u),g.append("model","whisper-large-v3-turbo"),g.append("response_format","verbose_json"),console.log("Calling Groq API with model whisper-large-v3-turbo and verbose_json...");const f=Date.now(),h=await fetch("https://api.groq.com/openai/v1/audio/transcriptions",{method:"POST",headers:{Authorization:`Bearer ${c}`},body:g}),w=Date.now();if(console.log(`Groq API call finished in ${w-f}ms. Status: ${h.status}`),!h.ok){let e="Unknown API error";try{const o=await h.json();e=o?.error?.message||JSON.stringify(o)}catch(o){e=await h.text()}throw new Error(`Groq API error: ${h.status} ${h.statusText}. Details: ${e}`)}const y=await h.json(),b=y?.text;if("string"!=typeof b)throw console.error("Groq API verbose_json response missing text field:",y),new Error("Groq API response did not contain valid transcription text.");console.log("Transcription successful."),await chrome.storage.local.set({transcriptionState:"complete",transcriptionResult:b,transcriptionError:null,pendingDownload:null}),chrome.runtime.sendMessage({action:"transcriptionComplete",transcription:b}).catch((e=>console.log("Popup not open?")))}catch(e){console.error("Error during audio processing or API call:",e);const o=e instanceof Error?e.message:"Unknown error during transcription processing";await chrome.storage.local.set({transcriptionState:"error",transcriptionError:o,transcriptionResult:null,pendingDownload:null}),chrome.runtime.sendMessage({action:"updatePopupState"}).catch((e=>console.log("Popup not open?")))}}(o.downloadId,n,a):(console.error("[Background] Cannot process audio data due to decoding failure or invalid data format."),chrome.storage.local.set({transcriptionState:"error",transcriptionError:"Internal error: Failed to decode/receive audio data correctly from fetch process.",pendingDownload:null}).then((()=>{chrome.runtime.sendMessage({action:"updatePopupState"}).catch((e=>console.log("Popup not open?")))})));break;case"audioFetchError":console.error(`Error fetching audio from offscreen document for downloadId ${o.downloadId}:`,o.error);const s=o.error||"Failed to fetch audio via offscreen document";chrome.storage.local.set({transcriptionState:"error",transcriptionError:s,pendingDownload:null}).then((()=>{chrome.runtime.sendMessage({action:"updatePopupState"}).catch((e=>console.log("Popup not open?")))}));break;case"clipboardDataResponse":console.log("Received clipboardDataResponse from offscreen"),async function(e){if(!e)return void console.log("Clipboard is empty or could not be read.");let o;console.log("Received clipboard content from offscreen:",e);try{if(o=new URL(e.trim()),!["http:","https:"].includes(o.protocol))throw new Error("Invalid protocol")}catch(o){return void console.log("Clipboard text is not a valid HTTP/HTTPS URL:",e)}console.log("Valid URL found in clipboard:",o.href);try{console.log("Valid URL format detected in clipboard. Preparing storage and starting transcription...");const e=await d(o.href,"clipboard");console.log(`Immediately starting transcription for clipboard URL, ID: ${e}`),await i(e)}catch(e){if(console.error("Error during URL validation or transcription initiation from clipboard:",e),!(e instanceof Error&&e.message.includes("Error preparing URL"))){const o=e instanceof Error?e.message:"Error starting transcription from clipboard URL.";await chrome.storage.local.set({transcriptionState:"error",transcriptionError:o}),chrome.runtime.sendMessage({action:"updatePopupState"}).catch((e=>console.log("Popup not open?")))}}}(o.data);break;case"clipboardReadError":console.error("Error reading clipboard from offscreen:",o.error),chrome.storage.local.set({transcriptionState:"error",transcriptionError:o.error||"Failed to read clipboard."}).then((()=>{chrome.runtime.sendMessage({action:"updatePopupState"}).catch((e=>console.log("Popup not open?")))}));break;default:console.warn("Received unknown action from offscreen:",o.action)}}return s})),console.log("Background script listeners attached.");const l="transcribeAudio";async function d(e,o){console.log(`Preparing pending download for URL from ${o}: ${e}`);const r=function(e){try{const o=new URL(e).pathname.split("/"),r=o[o.length-1];return r?decodeURIComponent(r):`audio_${Date.now()}.unknown`}catch(o){return console.warn(`Could not parse filename from URL: ${e}`,o),`audio_${Date.now()}.unknown`}}(e),t=Date.now();try{return await chrome.storage.local.set({pendingDownload:{downloadId:t,filename:r,url:e,fileSize:null,mime:null,isUrlSource:!0},transcriptionState:"pending_user_action",transcriptionResult:null,transcriptionError:null}),console.log(`Stored pending URL download (ID: ${t}) for: ${r}`),chrome.runtime.sendMessage({action:"updatePopupState"}).catch((e=>console.log("Popup not open or listening?"))),"clipboard"===o&&(console.log("URL processing via clipboard successful, closing offscreen document."),await c()),t}catch(e){console.error(`Error setting up storage for URL transcription (${o}):`,e);const r=e instanceof Error?e.message:"Error preparing URL for transcription.";throw await chrome.storage.local.set({transcriptionState:"error",transcriptionError:r}),chrome.runtime.sendMessage({action:"updatePopupState"}).catch((e=>console.log("Popup not open?"))),e}}chrome.runtime.onInstalled.addListener((()=>{chrome.contextMenus.create({id:l,title:"Transcribe Audio",contexts:["link","audio","video","page","selection"]}),console.log("Context menu created/updated.")})),chrome.contextMenus.onClicked.addListener(((e,o)=>{if(e.menuItemId===l){const o=e.linkUrl||e.srcUrl;if(o){console.log(`'Transcribe Audio' context menu clicked. Direct URL found: ${o}`);try{new URL(o),async function(e){console.log(`Handling direct transcription request for URL: ${e}`);try{const o=await d(e,"direct");console.log(`Immediately starting transcription for direct URL, ID: ${o}`),await i(o)}catch(o){console.error(`Error setting up or starting transcription from direct URL ${e}:`,o)}}(o)}catch(e){console.error(`Invalid URL detected from context menu: ${o}`,e),chrome.storage.local.set({transcriptionState:"error",transcriptionError:`Invalid URL provided: ${o}`}).then((()=>{chrome.runtime.sendMessage({action:"updatePopupState"}).catch((e=>console.log("Popup not open?")))}))}}else console.log("'Transcribe Audio' context menu clicked. No direct URL found, attempting clipboard read."),async function(){console.log("Initiating transcription via clipboard read...");try{await s(n),console.log("Sending read-clipboard request to offscreen document."),await chrome.storage.local.remove(["pendingDownload","transcriptionState","transcriptionResult","transcriptionError"]),await chrome.runtime.sendMessage({target:"offscreen",type:"read-clipboard"})}catch(e){console.error("Error initiating clipboard read via offscreen:",e);const o=e instanceof Error?e.message:"Failed to initiate clipboard reading.";await chrome.storage.local.set({transcriptionState:"error",transcriptionError:o}),chrome.runtime.sendMessage({action:"updatePopupState"}).catch((e=>console.log("Popup not open?")))}}()}}))})();